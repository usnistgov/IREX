<!-- HTML header for doxygen 1.9.3-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.3"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>FRTE/IREX Ongoing: Interface Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="FRTE_logo.png"/></td>
  <td id="projectalign">
   <div id="projectname">FRTE/IREX Ongoing
   </div>
   <div id="projectbrief">API Specification for the <A href="https://pages.nist.gov/frvt/html/frvt1N.html">FRTE 1:N</A> and <A href="https://pages.nist.gov/IREX10/">IREX</A> Evaluations</div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.svg"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('class_f_r_v_t__1_n_1_1_interface.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="class_f_r_v_t__1_n_1_1_interface-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Interface Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div></div>
</div><!--header-->
<div class="contents">

<p>The interface to FRVT 1:N implementation.  
 <a href="class_f_r_v_t__1_n_1_1_interface.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="frvt1_n_8h_source.html">frvt1N.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a60fa5fc9f5a32b9b60da02b2d569f13b"><td class="memItemLeft" align="right" valign="top">virtual FRVT::ReturnStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_r_v_t__1_n_1_1_interface.html#a60fa5fc9f5a32b9b60da02b2d569f13b">initializeTemplateCreation</a> (const std::string &amp;configDir, FRVT::TemplateRole role)=0</td></tr>
<tr class="memdesc:a60fa5fc9f5a32b9b60da02b2d569f13b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Before images are sent to the template creation function, the test harness will call this initialization function.  <a href="class_f_r_v_t__1_n_1_1_interface.html#a60fa5fc9f5a32b9b60da02b2d569f13b">More...</a><br /></td></tr>
<tr class="separator:a60fa5fc9f5a32b9b60da02b2d569f13b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5980a66474b92947e524988c93742e91"><td class="memItemLeft" align="right" valign="top">virtual FRVT::ReturnStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_r_v_t__1_n_1_1_interface.html#a5980a66474b92947e524988c93742e91">createFaceTemplate</a> (const std::vector&lt; FRVT::Image &gt; &amp;faces, FRVT::TemplateRole role, std::vector&lt; uint8_t &gt; &amp;templ, std::vector&lt; FRVT::EyePair &gt; &amp;eyeCoordinates)=0</td></tr>
<tr class="memdesc:a5980a66474b92947e524988c93742e91"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function supports template generation from one or more face images of exactly one person.  <a href="class_f_r_v_t__1_n_1_1_interface.html#a5980a66474b92947e524988c93742e91">More...</a><br /></td></tr>
<tr class="separator:a5980a66474b92947e524988c93742e91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1fe6b0a6afd26f18c3f1732400bc85c"><td class="memItemLeft" align="right" valign="top">virtual FRVT::ReturnStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_r_v_t__1_n_1_1_interface.html#ae1fe6b0a6afd26f18c3f1732400bc85c">createFaceTemplate</a> (const FRVT::Image &amp;image, FRVT::TemplateRole role, std::vector&lt; std::vector&lt; uint8_t &gt; &gt; &amp;templ, std::vector&lt; FRVT::EyePair &gt; &amp;eyeCoordinates)=0</td></tr>
<tr class="memdesc:ae1fe6b0a6afd26f18c3f1732400bc85c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function supports face template generation of one or more people detected from a single image.  <a href="class_f_r_v_t__1_n_1_1_interface.html#ae1fe6b0a6afd26f18c3f1732400bc85c">More...</a><br /></td></tr>
<tr class="separator:ae1fe6b0a6afd26f18c3f1732400bc85c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2622f02b43191a101219f718dcfd655"><td class="memItemLeft" align="right" valign="top">virtual FRVT::ReturnStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_r_v_t__1_n_1_1_interface.html#ab2622f02b43191a101219f718dcfd655">createIrisTemplate</a> (const std::vector&lt; FRVT::Image &gt; &amp;irises, FRVT::TemplateRole role, std::vector&lt; uint8_t &gt; &amp;templ, std::vector&lt; FRVT::IrisAnnulus &gt; &amp;irisLocations)=0</td></tr>
<tr class="memdesc:ab2622f02b43191a101219f718dcfd655"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function supports template generation from one or more iris images of exactly one person.  <a href="class_f_r_v_t__1_n_1_1_interface.html#ab2622f02b43191a101219f718dcfd655">More...</a><br /></td></tr>
<tr class="separator:ab2622f02b43191a101219f718dcfd655"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fccc4203ba6386a697ba6f04d7f2c0d"><td class="memItemLeft" align="right" valign="top">virtual FRVT::ReturnStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_r_v_t__1_n_1_1_interface.html#a2fccc4203ba6386a697ba6f04d7f2c0d">createFaceAndIrisTemplate</a> (const std::vector&lt; FRVT::Image &gt; &amp;facesIrises, FRVT::TemplateRole role, std::vector&lt; uint8_t &gt; &amp;templ)=0</td></tr>
<tr class="memdesc:a2fccc4203ba6386a697ba6f04d7f2c0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function supports template generation from one or more face and/or iris images of exactly one person.  <a href="class_f_r_v_t__1_n_1_1_interface.html#a2fccc4203ba6386a697ba6f04d7f2c0d">More...</a><br /></td></tr>
<tr class="separator:a2fccc4203ba6386a697ba6f04d7f2c0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a347777ac15bffcb4b7c007b22dc20fb0"><td class="memItemLeft" align="right" valign="top">virtual FRVT::ReturnStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_r_v_t__1_n_1_1_interface.html#a347777ac15bffcb4b7c007b22dc20fb0">finalizeEnrollment</a> (const std::string &amp;configDir, const std::string &amp;enrollmentDir, const std::string &amp;edbName, const std::string &amp;edbManifestName, FRVT_1N::GalleryType galleryType)=0</td></tr>
<tr class="memdesc:a347777ac15bffcb4b7c007b22dc20fb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will be called after all enrollment templates have been created and freezes the enrollment data.  <a href="class_f_r_v_t__1_n_1_1_interface.html#a347777ac15bffcb4b7c007b22dc20fb0">More...</a><br /></td></tr>
<tr class="separator:a347777ac15bffcb4b7c007b22dc20fb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10b94791139a11f404563c065368467f"><td class="memItemLeft" align="right" valign="top">virtual FRVT::ReturnStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_r_v_t__1_n_1_1_interface.html#a10b94791139a11f404563c065368467f">initializeIdentification</a> (const std::string &amp;configDir, const std::string &amp;enrollmentDir)=0</td></tr>
<tr class="memdesc:a10b94791139a11f404563c065368467f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will be called once prior to one or more calls to <a class="el" href="class_f_r_v_t__1_n_1_1_interface.html#af49ed974bae56667f3554a12256cd809" title="This function searches an identification template against the enrollment set, and outputs a vector co...">identifyTemplate()</a>.  <a href="class_f_r_v_t__1_n_1_1_interface.html#a10b94791139a11f404563c065368467f">More...</a><br /></td></tr>
<tr class="separator:a10b94791139a11f404563c065368467f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af49ed974bae56667f3554a12256cd809"><td class="memItemLeft" align="right" valign="top">virtual FRVT::ReturnStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_r_v_t__1_n_1_1_interface.html#af49ed974bae56667f3554a12256cd809">identifyTemplate</a> (const std::vector&lt; uint8_t &gt; &amp;idTemplate, const uint32_t candidateListLength, std::vector&lt; FRVT_1N::Candidate &gt; &amp;candidateList)=0</td></tr>
<tr class="memdesc:af49ed974bae56667f3554a12256cd809"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function searches an identification template against the enrollment set, and outputs a vector containing candidateListLength Candidates.  <a href="class_f_r_v_t__1_n_1_1_interface.html#af49ed974bae56667f3554a12256cd809">More...</a><br /></td></tr>
<tr class="separator:af49ed974bae56667f3554a12256cd809"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a6bd7c3943b434143f19228b219c26b01"><td class="memItemLeft" align="right" valign="top">static std::shared_ptr&lt; <a class="el" href="class_f_r_v_t__1_n_1_1_interface.html">Interface</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_r_v_t__1_n_1_1_interface.html#a6bd7c3943b434143f19228b219c26b01">getImplementation</a> ()</td></tr>
<tr class="memdesc:a6bd7c3943b434143f19228b219c26b01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory method to return a managed pointer to the <a class="el" href="class_f_r_v_t__1_n_1_1_interface.html" title="The interface to FRVT 1:N implementation.">Interface</a> object.  <a href="class_f_r_v_t__1_n_1_1_interface.html#a6bd7c3943b434143f19228b219c26b01">More...</a><br /></td></tr>
<tr class="separator:a6bd7c3943b434143f19228b219c26b01"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >The interface to FRVT 1:N implementation. </p>
<p >The submission software under test will implement this interface by sub-classing this class and implementing each method therein. </p>

<p class="definition">Definition at line <a class="el" href="frvt1_n_8h_source.html#l00078">78</a> of file <a class="el" href="frvt1_n_8h_source.html">frvt1N.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a8d07a756bb96ccfc79568730847385b4" name="a8d07a756bb96ccfc79568730847385b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d07a756bb96ccfc79568730847385b4">&#9670;&nbsp;</a></span>~Interface()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual ~<a class="el" href="class_f_r_v_t__1_n_1_1_interface.html">Interface</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="frvt1_n_8h_source.html#l00080">80</a> of file <a class="el" href="frvt1_n_8h_source.html">frvt1N.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a60fa5fc9f5a32b9b60da02b2d569f13b" name="a60fa5fc9f5a32b9b60da02b2d569f13b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60fa5fc9f5a32b9b60da02b2d569f13b">&#9670;&nbsp;</a></span>initializeTemplateCreation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual FRVT::ReturnStatus initializeTemplateCreation </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>configDir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FRVT::TemplateRole&#160;</td>
          <td class="paramname"><em>role</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Before images are sent to the template creation function, the test harness will call this initialization function. </p>
<p >This function will be called N=1 times by the NIST application, prior to parallelizing M &gt;= 1 calls to createTemplate() via fork().</p>
<p >This function will be called from a single process/thread.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">configDir</td><td>A read-only directory containing any developer-supplied configuration parameters or run-time data files. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">role</td><td>A value from the TemplateRole enumeration that indicates the intended usage of the template to be generated. In this case, either a 1:N enrollment template used for gallery enrollment or 1:N identification template used for search. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5980a66474b92947e524988c93742e91" name="a5980a66474b92947e524988c93742e91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5980a66474b92947e524988c93742e91">&#9670;&nbsp;</a></span>createFaceTemplate() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual FRVT::ReturnStatus createFaceTemplate </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; FRVT::Image &gt; &amp;&#160;</td>
          <td class="paramname"><em>faces</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FRVT::TemplateRole&#160;</td>
          <td class="paramname"><em>role</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; uint8_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>templ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; FRVT::EyePair &gt; &amp;&#160;</td>
          <td class="paramname"><em>eyeCoordinates</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function supports template generation from one or more face images of exactly one person. </p>
<p >It takes as input a vector of images and outputs a template and associated eye coordinates</p>
<p >For enrollment templates: If the function executes correctly (i.e. returns a successful exit status), the template will be enrolled into a gallery. The NIST calling application may store the resulting template, concatenate many templates, and pass the result to the enrollment finalization function.</p>
<p >When the implementation fails to produce a template, it shall still return a blank template (which can be zero bytes in length). The template will be included in the enrollment database/manifest like all other enrollment templates, but is not expected to contain any feature information. <br  />
For identification templates: If the function returns a non-successful return status, the output template will be not be used in subsequent search operations.</p>
<p >In the rare event that more than one face is detected in an image, features should be extracted from the foreground face, that is, the largest face in the image.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">faces</td><td>A vector of input face images </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">role</td><td>A value from the TemplateRole enumeration that indicates the intended usage of the template to be generated. In this case, either a 1:N enrollment template used for gallery enrollment or 1:N identification template used for search. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">templ</td><td>The output template. The format is entirely unregulated. This will be an empty vector when passed into the function, and the implementation can resize and populate it with the appropriate data. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">eyeCoordinates</td><td>(Optional) The function may choose to return the estimated eye centers for the input face images. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae1fe6b0a6afd26f18c3f1732400bc85c" name="ae1fe6b0a6afd26f18c3f1732400bc85c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1fe6b0a6afd26f18c3f1732400bc85c">&#9670;&nbsp;</a></span>createFaceTemplate() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual FRVT::ReturnStatus createFaceTemplate </td>
          <td>(</td>
          <td class="paramtype">const FRVT::Image &amp;&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FRVT::TemplateRole&#160;</td>
          <td class="paramname"><em>role</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; uint8_t &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>templ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; FRVT::EyePair &gt; &amp;&#160;</td>
          <td class="paramname"><em>eyeCoordinates</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function supports face template generation of one or more people detected from a single image. </p>
<p >It takes a single input image and outputs one or more proprietary templates and associated eye coordinates based on the number of people detected.</p>
<p >For enrollment templates: If the function executes correctly (i.e. returns a successful exit status), the template(s) will be enrolled into a gallery. The NIST calling application may store the resulting template(s), concatenate many templates, and pass the result to the enrollment finalization function. The resulting template(s) may also be inserted immediately into a previously finalized gallery. When the implementation fails to produce a template, it shall still return a blank template (which can be zero bytes in length). The template will be included in the enrollment database/manifest like all other enrollment templates, but is not expected to contain any feature information. <br  />
For identification templates: If the function returns a non-successful return status, the output template(s) will be not be used in subsequent search operations.</p>
<p >param[in] image A single image that contains one or more people in the photo param[in] role Label describing the type/role of the template to be generated param[out] templs A vector of output template(s). The format of the template(s) is entirely unregulated. This will be an empty vector when passed into the function, and the implementation can resize and populate it with the appropriate data. param[out] eyeCoordinates For each person detected in the image, the function shall return the estimated eye centers. This will be an empty vector when passed into the function, and the implementation shall populate it with the appropriate number of entries. Values in eyeCoordinates[i] shall correspond to templs[i]. </p>

</div>
</div>
<a id="ab2622f02b43191a101219f718dcfd655" name="ab2622f02b43191a101219f718dcfd655"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2622f02b43191a101219f718dcfd655">&#9670;&nbsp;</a></span>createIrisTemplate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual FRVT::ReturnStatus createIrisTemplate </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; FRVT::Image &gt; &amp;&#160;</td>
          <td class="paramname"><em>irises</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FRVT::TemplateRole&#160;</td>
          <td class="paramname"><em>role</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; uint8_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>templ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; FRVT::IrisAnnulus &gt; &amp;&#160;</td>
          <td class="paramname"><em>irisLocations</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function supports template generation from one or more iris images of exactly one person. </p>
<p >It takes as input a vector of images and outputs a template and optionally, the associated location of the iris in each image.</p>
<p >For enrollment templates: If the function executes correctly (i.e. returns a successful exit status), the template will be enrolled into a gallery. The NIST calling application may store the resulting template, concatenate many templates, and pass the result to the enrollment finalization function.</p>
<p >When the implementation fails to produce a template, it shall still return a blank template (which can be zero bytes in length). The template will be included in the enrollment database/manifest like all other enrollment templates, but is not expected to contain any feature information. <br  />
For identification templates: If the function returns a non-successful return status, the output template will be not be used in subsequent search operations.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">irises</td><td>A vector of input iris images </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">role</td><td>A value from the TemplateRole enumeration that indicates the intended usage of the template to be generated. In this case, either a 1:N enrollment template used for gallery enrollment or 1:N identification template used for search. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">templ</td><td>The output template. The format is entirely unregulated. This will be an empty vector when passed into the function, and the implementation can resize and populate it with the appropriate data. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">irisLocations</td><td>(Optional) The function may choose to return the estimated iris locations for the input iris images. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2fccc4203ba6386a697ba6f04d7f2c0d" name="a2fccc4203ba6386a697ba6f04d7f2c0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fccc4203ba6386a697ba6f04d7f2c0d">&#9670;&nbsp;</a></span>createFaceAndIrisTemplate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual FRVT::ReturnStatus createFaceAndIrisTemplate </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; FRVT::Image &gt; &amp;&#160;</td>
          <td class="paramname"><em>facesIrises</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FRVT::TemplateRole&#160;</td>
          <td class="paramname"><em>role</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; uint8_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>templ</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function supports template generation from one or more face and/or iris images of exactly one person. </p>
<p >It takes as input a vector of images and outputs a template. NOTE: The implementation must handle both multimodal and unimodal samples for enrollment and probe template generation where the input is 1) face and iris images or 2) face image(s) only or 3) iris image(s) only. For example, a gallery might be generated for which 80% of enrolled samples are face and iris, but 10% of samples are face-only, and 10% are iris-only. This reflects operational reality, but we anticipate exercising mostly multimodal enrollments and searches.</p>
<p >For enrollment templates: If the function executes correctly (i.e. returns a successful exit status), the template will be enrolled into a gallery. The NIST calling application may store the resulting template, concatenate many templates, and pass the result to the enrollment finalization function.</p>
<p >When the implementation fails to produce a template, it shall still return a blank template (which can be zero bytes in length). The template will be included in the enrollment database/manifest like all other enrollment templates, but is not expected to contain any feature information. <br  />
For identification templates: If the function returns a non-successful return status, the output template will be not be used in subsequent search operations.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">facesIrises</td><td>A vector of input face and/or iris images </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">role</td><td>A value from the TemplateRole enumeration that indicates the intended usage of the template to be generated. In this case, either a 1:N enrollment template used for gallery enrollment or 1:N identification template used for search. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">templ</td><td>The output template. The format is entirely unregulated. This will be an empty vector when passed into the function, and the implementation can resize and populate it with the appropriate data. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a347777ac15bffcb4b7c007b22dc20fb0" name="a347777ac15bffcb4b7c007b22dc20fb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a347777ac15bffcb4b7c007b22dc20fb0">&#9670;&nbsp;</a></span>finalizeEnrollment()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual FRVT::ReturnStatus finalizeEnrollment </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>configDir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>enrollmentDir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>edbName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>edbManifestName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FRVT_1N::GalleryType&#160;</td>
          <td class="paramname"><em>galleryType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function will be called after all enrollment templates have been created and freezes the enrollment data. </p>
<p >After this call, the enrollment dataset will be forever read-only.</p>
<p >This function allows the implementation to conduct, for example, statistical processing of the feature data, indexing and data re-organization. The function may create its own data structure. It may increase or decrease the size of the stored data. No output is expected from this function, except a return code. The function will generally be called in a separate process after all the enrollment processes are complete. NOTE: Implementations shall not move the input data. Implementations shall not point to the input data. Implementations should not assume the input data would be readable after the call. Implementations must, <b>at a minimum, copy the input data</b> or otherwise extract what is needed for search.</p>
<p >This function will be called from a single process/thread.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">configDir</td><td>A read-only directory containing any developer-supplied configuration parameters or run-time data files. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">enrollmentDir</td><td>The top-level directory in which enrollment data was placed. This variable allows an implementation to locate any private initialization data it elected to place in the directory. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">edbName</td><td>The name of a single file containing concatenated templates, i.e. the EDB described in <em>File structure for enrolled template collection</em>. While the file will have read-write-delete permission, the implementation should only alter the file if it preserves the necessary content, in other files for example. The file may be opened directly. It is not necessary to prepend a directory name. This is a NIST-provided input - implementers shall not internally hard-code or assume any values. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">edbManifestName</td><td>The name of a single file containing the EDB manifest described in <em>File structure for enrolled template collection</em>. The file may be opened directly. It is not necessary to prepend a directory name. This is a NIST-provided input - implementers shall not internally hard-code or assume any values. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">galleryType</td><td>The composition of the gallery as enumerated by GalleryType. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a10b94791139a11f404563c065368467f" name="a10b94791139a11f404563c065368467f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10b94791139a11f404563c065368467f">&#9670;&nbsp;</a></span>initializeIdentification()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual FRVT::ReturnStatus initializeIdentification </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>configDir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>enrollmentDir</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function will be called once prior to one or more calls to <a class="el" href="class_f_r_v_t__1_n_1_1_interface.html#af49ed974bae56667f3554a12256cd809" title="This function searches an identification template against the enrollment set, and outputs a vector co...">identifyTemplate()</a>. </p>
<p >The function might set static internal variables and read the enrollment gallery into memory so that the enrollment database is available to the subsequent identification searches.</p>
<p >This function will be called from a single process/thread.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">configDir</td><td>A read-only directory containing any developer-supplied configuration parameters or run-time data files. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">enrollmentDir</td><td>The read-only top-level directory in which enrollment data was placed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af49ed974bae56667f3554a12256cd809" name="af49ed974bae56667f3554a12256cd809"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af49ed974bae56667f3554a12256cd809">&#9670;&nbsp;</a></span>identifyTemplate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual FRVT::ReturnStatus identifyTemplate </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; uint8_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>idTemplate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>candidateListLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; FRVT_1N::Candidate &gt; &amp;&#160;</td>
          <td class="paramname"><em>candidateList</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function searches an identification template against the enrollment set, and outputs a vector containing candidateListLength Candidates. </p>
<p >Each candidate shall be populated by the implementation and added to candidateList. Note that candidateList will be an empty vector when passed into this function. <br  />
</p>
<p >For face recognition: the candidates shall appear in descending order of similarity score - i.e. most similar entries appear first. For iris recognition: the candidates shall appear in ascending order of dissimilarity - i.e. the least dissimilar entries appear first. For multimodal face and iris, the candidates shall appear in descending order of similarity score - i.e. most similar entries appear first.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">idTemplate</td><td>A template from the implemented template creation function. If the value returned by that function was non-successful, the contents of idTemplate will not be used, and this function will not be called.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">candidateListLength</td><td>The number of candidates the search should return. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">candidateList</td><td>Each candidate shall be populated by the implementation. The candidates shall appear in descending order of similarity score - i.e. most similar entries appear first. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6bd7c3943b434143f19228b219c26b01" name="a6bd7c3943b434143f19228b219c26b01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bd7c3943b434143f19228b219c26b01">&#9670;&nbsp;</a></span>getImplementation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::shared_ptr&lt; <a class="el" href="class_f_r_v_t__1_n_1_1_interface.html">Interface</a> &gt; getImplementation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Factory method to return a managed pointer to the <a class="el" href="class_f_r_v_t__1_n_1_1_interface.html" title="The interface to FRVT 1:N implementation.">Interface</a> object. </p>
<p >This function is implemented by the submitted library and must return a managed pointer to the <a class="el" href="class_f_r_v_t__1_n_1_1_interface.html" title="The interface to FRVT 1:N implementation.">Interface</a> object.</p>
<dl class="section note"><dt>Note</dt><dd>A possible implementation might be: return (std::make_shared&lt;Implementation&gt;()); </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="frvt1_n_8h_source.html">frvt1N.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>FRVT_1N</b></li><li class="navelem"><a class="el" href="class_f_r_v_t__1_n_1_1_interface.html">Interface</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.3 </li>
  </ul>
</div>
</body>
</html>
